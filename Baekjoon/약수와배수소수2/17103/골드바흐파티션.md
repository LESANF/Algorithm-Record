# 골드바흐 파티션

## 문제

골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.

짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다.

짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.

## 입력

첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2 < N ≤ 1,000,000을 만족한다.

## 출력

```
각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.
```

## 예제 입력

```
5
6
8
10
12
100
```

## 예제 출력

```
1
1
2
1
6
```

## 내 제출

```js
/********************************************/
실패 - 시간초과

나름 정리하고 풀었는데 시간초과가 나버렸다.

1. 에라토스테네스의 체로 소수 구하기
2. 해당 소수를 Map에 맵핑
3. 파티션 구하기
4. 파티션에서 중복되는값 제거

해당 플로우로 풀었는데, 시간초과가 났다. 정답은 맞음

const fs = require("fs");
const [N, ...rest] = fs
  .readFileSync(process.platform === "linux" ? "/dev/stdin" : "예제.txt")
  .toString()
  .trim()
  .split("\n")
  .map(Number);

for (let x = 0; x < N; x++) {
  const currentNumber = rest[x];

  let board = Array.from({ length: currentNumber }).fill(true);
  for (let y = 2; y <= Math.floor(Math.sqrt(currentNumber)); y++) {
    for (let z = 2; z * y <= currentNumber; z++) {
      board[z * y - 1] = false;
    }
  }

  const primeMap = new Map();
  board.forEach((value, index) => {
    if (value && index !== 0) primeMap.set(index + 1, index + 1);
  });

  const setPartition = new Map();
  for (let value of primeMap.keys()) {
    primeMap.has(currentNumber - value) &&
      setPartition.set(value, currentNumber - value);
  }

  for (let [key, value] of setPartition) {
    if (key === value) continue;
    setPartition.get(value) === key && setPartition.delete(key);
  }

  console.log(setPartition.size);
}

```
